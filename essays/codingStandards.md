---
layout: essay
type: essay
title: "Coding Personality Standards"
# All dates must be YYYY-MM-DD format!
date: 2025-09-04
published: true
labels:
  - Typescript
  - Learning
  - Lint
---

<img width="200px" class="rounded float-start pe-4" src="../img/noisy/noisyimg.jpg">

## The Personality of the Language
Coding standards can be pretty annoying when you first start coding, but over time you adapt and the number of errors you run into gets smaller and smaller. They’re essentially guidelines for how to write in a given programming language, and almost every language has its own quirks or unique rules that set it apart from others. In a way, coding standards are like the “personality” of a language. Their main purpose is to reduce simple mistakes and make code more consistent and readable, not just for yourself, but also for other software engineers who might need to read or maintain it later.

## Linting Lessons
When I first started using ESLint in VSCode, it was a little painful. Every few lines I typed, new errors would pop up. I’d go back and fix them, but sometimes they were so basic that it was just annoying, while other times I’d get stuck on errors I didn’t understand and found confusing. Over time though, I got used to it and stopped repeating the same mistakes. For the errors I didn’t understand, I would search them up, and that usually helped me realize why the code I wrote initially wasn’t the best approach. Little by little, it taught me better coding habits in the language.

## Final Thoughts
For TypeScript, the errors I still struggle with the most are type-related. There are so many different types with specific use cases that I’m often unsure which one to use. But that’s expected since TypeScript is built around its strong type system. With C, on the other hand, the linter usually catches things like memory leak warnings. That’s why I think coding standards really reflect the language itself. They highlight what’s most important to watch out for. Whether it’s memory management in C or type correctness in TypeScript. In the end, they serve as a great tool to better understand the uniqueness of each language.
